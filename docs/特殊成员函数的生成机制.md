## 特殊成员函数的生成机制

特殊成员函数指的是那些 `C++` 会自动生成的函数，这些函数只在有需要时才会生成，意思是在某些代码中使用了它们编译器就会生成它们。特殊成员函数包括：`拷贝构造函数`、`拷贝赋值运算符`、`移动构造函数`、`移动赋值运算符`、`默认构造函数`、`析构函数`

首先是关于 `拷贝操作` 和 `移动操作` 彼此之间的相互作用：

1. 两种拷贝操作是彼此独立的：声明了其中的一个并不会阻止编译器生成另一个
2. 两种移动操作并不是独立的：当显示声明了其中的一个时，编译器就不会生成另一个
   - 这么做是有理由的。假设声明了一个移动操作，实际上你表明的是移动操作的实现方式将会与编译器默认生成的移动操作多少有一些不同，那么编译器就不会为你生成另一个移动操作
3. 如果显示声明了拷贝操作，则编译器就不会为该类生成移动操作
   - 这么做的理由还是和之前一样，声明拷贝操作的行为表明了常规的编译器生成的拷贝方式不太适合。所以编译器会判定既然按成员拷贝不适合，那么按成员移动也极有可能不适合，就不会生成移动操作了
4. 声明了移动操作，编译器就会阻止生成拷贝操作
   - 理由和第三点一样

> 编译器生成的移动操作是按成员移动的，但是不保证一定会执行移动操作。对于那些不可移动的类型，编译器会采用拷贝操作

正常来说如果你声明了 `拷贝构造函数`、`拷贝赋值运算符`、`析构函数` 三者中的其中一个，你就得同时声明所有的三个。这样的思想源于如果有改写拷贝操作的需求，就意味着该类需要执行某种资源管理

1. 在一个拷贝操作中进行资源管理，极有可能在另一个拷贝操作中需要进行
2. 析构函数也是会参与到资源管理中的

另外如果声明了 `析构函数` 那么编译器就不会生成移动操作了。这可以理解为，析构函数的性质和拷贝操作是类似的，既然拷贝操作会阻止，那么析构函数也会阻止

最后如果用户自己定义了构造函数则不会生成 `默认构造函数`，`析构函数` 唯一的特点就是如果基类中的析构函数是 `virtual` 的则默认生成的析构函数也是 `virtual` 的